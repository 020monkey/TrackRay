package com.trackray.base.exploit;

import com.trackray.base.bean.*;
import com.trackray.base.httpclient.CrawlerPage;
import com.trackray.base.httpclient.Fetcher;
import com.trackray.base.utils.PageUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * exploit抽象类
 * @author 浅蓝
 * @email blue@ixsec.org
 * @since 2019/1/8 12:28
 */
public abstract class AbstractExploit implements Runnable{
    protected static Fetcher fetcher = new Fetcher();
    public CrawlerPage crawlerPage = new CrawlerPage();
    private String target;
    private static final Logger log = LoggerFactory.getLogger(AbstractExploit.class);
    private List<Vulnerable> vulns = new ArrayList<>();
    private Task task;
    private Map<String,Object> tempMap = new HashMap<>();

    public void init(Task task){
        //...
    }
/*    public void attackAfter(Task task){
        //...
        CrawlerPage page = new CrawlerPage();
        page.getRequest().setUrl(Constant.Vuln.VULN_ADD_API);
        page.getRequest().setHttpMethod(HttpMethod.POST);
        page.getRequest().addHttpHeader("Content-Type","application/x-www-form-urlencoded");
        page.getRequest().addHttpHeader("Connection: keep-alive");

        HashMap<String, String> param = new HashMap<>();
        for (Vulnerable vuln : vulns) {
            try {
                param.clear();
                param.put("md5",task.getTaskMD5());
                param.put("payload",vuln.getPayload());
                param.put("message",vuln.getMessage());
                param.put("vulnid",vuln.getVulnInfo().getVulnID());
                param.put("aboutLink",vuln.getVulnInfo().getAboutLink());
                param.put("vulnType",String.valueOf(vuln.getVulnInfo().getVulnType().getId()));
                param.put("response",vuln.getResponse().toString());
                param.put("level",String.valueOf(vuln.getVulnInfo().getVulnLevel().getLevel()));
                page.getRequest().setParamMap(param);
                fetcher.run(page);
            }catch (Exception e){}
        }
    };*/
    public void attackAfter(){

        task.getResult().getItems().get(target);

    }
    protected void addVul(Vulnerable vulnerable){
        getVulns().add(vulnerable);
    }
    public abstract void attack(Task task);
    public abstract boolean check(Result result);
    private final void todo(){}
    @Override
    public void run() {
        executor();
    }
    public void executor(){
        PageUtils.copyTaskProxy(task,crawlerPage);
        if (check(task.getResult())){

            init(task);
            log.info("exploit init...");

            attack(task);
            if (!vulns.isEmpty())
            {
                log.info("exploit attack success...");
                attackAfter();
            }else{
                log.info("not vulnerable...");
            }
        }
    }
    protected  List<Vulnerable> vulns(){return getVulns();}
    private List<Vulnerable> getVulns() {
        return vulns;
    }

    public Map<String, Object> getTempMap() {
        return tempMap;
    }

    public Task getTask() {
        return task;
    }

    public void setTask(Task task) {
        this.task = task;
    }

    public String getTarget() {
        return target;
    }

    public void setTarget(String target) {
        this.target = target;
    }
}
